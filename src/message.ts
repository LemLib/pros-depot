import { Octokit } from '@octokit/rest'
import { Depot, DepotEntry, DepotLocation } from './types'
import { homepage as actionURL } from '../package.json'

function jsonToDepot(json: string): Depot {
  return JSON.parse(json)
}

async function getOldJson(
  location: DepotLocation,
  client: Octokit
): Promise<string> {
  const res = await client.repos.getContent({
    ...location,
    ref: location.branch
  })
  return res.data.toString()
}

function depotEntryIsEqual(temp1: DepotEntry, temp2: DepotEntry): boolean {
  return (
    (['version', 'name', 'supported_kernels', 'target'] as const).every(
      key => temp1[key] === temp2[key]
    ) && temp1.metadata.location === temp2.metadata.location
  )
}

/**
 * Adds gitmoji and explains that the commit is the result of automation
 * @param message
 * @returns
 */
function formatCommitMessage(message: string): string {
  const gitmoji = ':bookmark:'
  const automationMessage = `This commit was generated by an automated workflow: ${actionURL}`
  let msg = message
  if (!msg.trim().startsWith(':')) msg = gitmoji + ' ' + msg
  msg += '\n\n'
  msg += automationMessage
  return msg
}

/**
 *
 * @param newJson
 * @param location
 * @param client
 * @returns formatted commit message unless the json's are the same, in which case it returns undefined, indicating that no commit is necessary
 */
export async function createCommitMessage(
  newJson: string,
  location: DepotLocation,
  client: Octokit
): Promise<string | undefined> {
  const raw = await createRawMessage(newJson, location, client)
  if (raw === undefined) return raw
  else return formatCommitMessage(raw)
}

async function createRawMessage(
  newJson: string,
  location: DepotLocation,
  client: Octokit
): Promise<string | undefined> {
  const oldJson = await getOldJson(location, client)

  if (oldJson === newJson) return undefined
  if (oldJson === '') return `:tada: Create Depot: ${location.path}`

  const oldDepot = jsonToDepot(oldJson)
  const newDepot = jsonToDepot(newJson)

  const changedTemplates: DepotEntry[] = []
  for (const template of newDepot) {
    if (
      !oldDepot.some(oldTemplate => depotEntryIsEqual(template, oldTemplate))
    ) {
      changedTemplates.push(template)
    }
  }

  if (changedTemplates.length === 1) {
    if (
      oldDepot.some(
        oldTemplate => oldTemplate.version == changedTemplates[0].version
      )
    )
      return `Update ${changedTemplates[0].version}`
    else return `Add ${changedTemplates[0].version}`
  }
  if (changedTemplates.length > 1) return 'Update multiple versions'
  return 'Update depot'
}
